# LuaJIT Documentation

## Overview

LuaJIT is a Just-In-Time (JIT) compiler for the Lua programming language. It combines high flexibility with high performance and an unmatched low memory footprint.

LuaJIT is part of a hundred million web sites, huge SaaS installations, network switches, set-top boxes and other embedded devices. You've probably already used LuaJIT without knowing about it.

Key features include:
- High-performance trace compiler with advanced SSA-based optimizations
- Tightly integrated Foreign Function Interface (FFI) for calling C functions
- String buffers for efficient string manipulation
- Built-in profiler for performance analysis
- Compatible with Lua 5.1 API and ABI
- Runs on multiple platforms including Windows, Linux, BSD, macOS, Android, iOS, and gaming consoles

## Key Features

### Trace Compiler
LuaJIT features an innovative trace compiler that is integrated with advanced, SSA-based optimizations and highly tuned code generation backends. This allows it to break into the performance range traditionally reserved for offline, static language compilers.

### Foreign Function Interface (FFI)
The FFI library allows calling external C functions and using C data structures from pure Lua code. It largely obviates the need to write tedious manual Lua/C bindings in C.

Key benefits:
- Parses plain C declarations (can be cut-n-pasted from C header files)
- No need to learn a separate binding language
- Code generated by the JIT-compiler for accesses to C data structures is on par with C compiler output
- Calls to C functions can be inlined in JIT-compiled code

### String Buffers
Efficient string manipulation with zero-copy operations and automatic memory management.

### Profiler
Built-in profiler for analyzing performance bottlenecks in Lua code.

## Key Functions

### FFI Library Functions

#### `ffi.cdef`
Defines C declarations that can be used in Lua code.

Syntax:
```lua
ffi.cdef([[C declarations]])
```

Example:
```lua
ffi.cdef[[int printf(const char *fmt, ...);]]
```

#### `ffi.C`
Access to C functions and variables declared with `ffi.cdef`.

Example:
```lua
ffi.C.printf("Hello %s!", "world")
```

#### `ffi.new`
Allocates and initializes a C data structure.

Syntax:
```lua
ffi.new(ct, [nelem,] [init])
```

Parameters:
- `ct`: C type
- `nelem`: Number of elements (optional)
- `init`: Initialization value (optional)

#### `ffi.cast`
Casts a value to a different C type.

Syntax:
```lua
ffi.cast(ct, init)
```

Parameters:
- `ct`: Target C type
- `init`: Value to cast

#### `ffi.typeof`
Returns the C type of a value or declaration.

Syntax:
```lua
ffi.typeof(ct)
```

Parameters:
- `ct`: C type or value

### String Buffer Functions

#### `buffer.new`
Creates a new string buffer.

Syntax:
```lua
local buf = buffer.new()
```

#### `buffer:put`
Appends data to the buffer.

Syntax:
```lua
buf:put(data)
```

Parameters:
- `data`: String or number to append

#### `buffer:get`
Returns the accumulated string.

Syntax:
```lua
local str = buf:get()
```

### Profiler Functions

#### `jit.p`
Controls the profiler.

Syntax:
```lua
jit.p([mode[, output]])
```

Parameters:
- `mode`: Profiler mode ("s" for start, "t" for stop, etc.)
- `output`: Output file or function

#### `jit.v`
Controls the profiler viewer.

Syntax:
```lua
jit.v([mode[, output]])
```

Parameters:
- `mode`: Viewer mode
- `output`: Output file or function

## Usage Notes

1. LuaJIT is a drop-in replacement for Lua 5.1 - existing Lua code should work without modification
2. The FFI library provides seamless integration with C libraries
3. String buffers are more efficient than string concatenation for building large strings
4. The profiler can be used to identify performance bottlenecks in Lua code
5. LuaJIT supports multiple architectures including x86, x64, ARM, ARM64, PPC, and MIPS
6. LuaJIT is compatible with various operating systems including Linux, Windows, macOS, and embedded systems

## Example Usage

### Basic FFI Usage

```lua
local ffi = require("ffi")

-- Define C functions
ffi.cdef[[
int printf(const char *fmt, ...);
]]

-- Call C function
ffi.C.printf("Hello %s!\n", "world")
```

### Working with C Structures

```lua
local ffi = require("ffi")

-- Define a C structure
ffi.cdef[[
typedef struct {
    int x, y;
} Point;
]]

-- Create and use a C structure
local point = ffi.new("Point", {x = 10, y = 20})
print(point.x, point.y)  -- Output: 10 20

-- Modify the structure
point.x = 100
print(point.x)  -- Output: 100
```

### Using String Buffers

```lua
local buffer = require("buffer")

-- Create a buffer
local buf = buffer.new()

-- Append data efficiently
for i = 1, 1000 do
    buf:put("Item ")
    buf:put(i)
    buf:put("\n")
end

-- Get the final string
local result = buf:get()
print("Generated " .. #result .. " characters")
```

### Using the Profiler

```lua
-- Start profiling
jit.p("s")

-- Your code here
for i = 1, 1000000 do
    local x = i * i
end

-- Stop profiling and view results
jit.p("t")
jit.v("s")
```